[[oracles_chap]]
== Oracles

((("oracles", id="ix_11oracles-asciidoc0", range="startofrange")))In this chapter we discuss _oracles_, which are systems that can provide external data sources to Ethereum smart contracts. The term "oracle" comes from Greek mythology, where it referred to a person in communication with the gods who could see visions of the future. In the context of blockchains, an oracle is a system that can answer questions that are external to Ethereum. ((("trustless systems", seealso="oracles")))Ideally oracles are systems that are _trustless_, meaning that they do not need to be trusted because they operate on decentralized principles.

이 장에서는 이더리움 스마트 계약에 외부 데이터 소스를 제공 할 수 있는 시스템인 오라클에 대해 설명합니다. "오라클"이라는 용어는 그리스 신화에서 유래 한 것으로 미래의 비전을 볼 수있는 신들과 의사 소통을 하는 사람을 지칭합니다. 블록체인의 맥락에서 오라클은 이더리움 외부의 질문에 대답 할 수 있는 시스템입니다. 이상적인 오라클은 _trustless_로, 분산된 원칙에 따라 작동하므로 신뢰할 필요가 없습니다.

[[why_oracles]]
=== Why Oracles Are Needed

((("oracles","reasons for using")))A key component of the Ethereum platform is the Ethereum Virtual Machine, with its ability to execute programs and update the state of Ethereum, constrained by consensus rules, on any node in the decentralized network. In order to maintain consensus, EVM execution must be totally deterministic and based only on the shared context of the Ethereum state and signed transactions. This has two particularly important consequences: the first is that there can be no intrinsic source of randomness for the EVM and smart contracts to work with; the second is that extrinsic data can only be introduced as the data payload of a transaction.

Let's unpack those two consequences further. To understand the prohibition of a true random function in the EVM to provide randomness for smart contracts, consider the effect on attempts to achieve consensus after the execution of such a function: node A would execute the command and store +3+ on behalf of the smart contract in its storage, while node B, executing the same smart contract, would store +7+ instead. Thus, nodes A and B would come to different conclusions about what the resulting state should be, despite having run exactly the same code in the same context. Indeed, it could be that a different resulting state would be achieved every time that the smart contract is evaluated. As such, there would be no way for the network, with its multitude of nodes running independently around the world, to ever come to a decentralized consensus on what the resulting state should be. In practice, it would get much worse than this example very quickly, because knock-on effects, including ether transfers, would build up exponentially.

Ethereum 플랫폼의 핵심 구성 요소는 Ethereum Virtual Machine으로, 분산 네트워크의 모든 노드에서 합의 규칙에 의해 제한되는 프로그램을 실행하고 Ethereum의 상태를 업데이트 할 수 있습니다. 합의를 유지하기 위해 EVM 실행은 완전히 결정적이어야하며 이더리움 상태 및 서명 된 트랜잭션의 공유 컨텍스트에만 기반해야합니다. 이는 두 가지 중요한 결과를 가져옵니다. 첫 번째는 EVM 및 스마트 계약이 작동 할 수 있는 instrinsic source of randomness가 없다는 것입니다. 두 번째는 외부 데이터가 트랜잭션의 데이터 페이로드로만 도입 될 수 있다는 것입니다.

이 두 가지 결과를 더 풀자. 스마트 컨트랙트에 대한 임의성을 제공하기 위한 EVM에서 진정한 랜덤 함수의 금지를 이해하려면 이러한 기능을 실행 한 후 합의를 달성하려는 시도에 미치는 영향을 고려하십시오. 노드 A는 스마트 컨트랙트 대신 명령을 실행하고 3을 저장합니다. 동일한 스마트 계약을 실행하는 노드 B는 대신 스토리지에 7을 저장합니다. 따라서 노드 A와 B는 동일한 컨텍스트에서 정확히 동일한 코드를 실행 했음에도 불구하고 결과 상태가 무엇인지에 대해 다른 결론을 내립니다. 실제로, 스마트 계약이 평가 될 때마다 다른 결과 상태가 달성 될 수 있습니다. 따라서 전 세계에서 여러 노드가 독립적으로 실행되는 네트워크가 결과 상태가 무엇인지에 대한 분산된 합의에 도달 할 수 있는 방법이 없습니다. 실제로, 이더 이전을 포함한 knock-on 효과는 기하 급수적으로 증가하기 때문에 이 예제보다 훨씬 더 나빠질 것입니다.

Note that pseudorandom functions, such as cryptographically secure hash functions (which are deterministic and therefore can be, and indeed are, part of the EVM), are not enough for many applications. Take a gambling game that simulates coin flips to resolve bet payouts, which needs to randomize heads or tails&#x2014;a miner can gain an advantage by playing the game and only including their transactions in blocks for which they will win. So how do we get around this problem? Well, all nodes can agree on the contents of signed transactions, so extrinsic information, including sources of randomness, price information, weather forecasts, etc., can be introduced as the data part of transactions sent to the network. However, such data simply cannot be trusted, because it comes from unverifiable sources. As such, we have just deferred the problem. We use oracles to attempt to solve these problems, which we will discuss in detail, in the rest of this chapter.

암호로 안전한 해시 함수 (결정적이며 따라서 EVM의 일부일 수 있음)와 같은 의사 난수 함수는 많은 응용 프로그램에 충분하지 않습니다. 베팅 지불을 해결하기 위해 코인 플립을 시뮬레이션하는 도박 게임을 통해 앞면이나 뒷면을 무작위로 배정해야 하는 경우. a miner can gain an advantage by playing the game and only including their transactions in blocks for which they will win. 그렇다면 이 문제를 어떻게 해결할 수 있습니까? 모든 노드는 서명된 트랜잭션의 내용에 동의할 수 있으므로 임의의 출처, 가격 정보, 일기 예보 등을 포함한 외부 정보를 네트워크로 전송되는 트랜잭션의 데이터 부분으로 도입 할 수 있습니다. 그러나 이러한 데이터는 확인할 수 없는 출처에서 가져 오기 때문에 단순히 신뢰할 수 없습니다. 따라서 우리는 방금 문제를 연기했습니다. 우리는이 장의 나머지 부분에서 오라클을 사용하여 이러한 문제를 해결하려고 시도합니다.

[[oracle_use_cases]]
=== Oracle Use Cases and Examples

((("oracles","use cases/examples")))Oracles, ideally, provide a trustless (or at least near-trustless) way of getting extrinsic (i.e., "rea-world" or off-chain) information, such as the results of football games, the price of gold, or truly random numbers, onto the Ethereum platform for smart contracts to use. They can also be used to relay data securely to DApp frontends directly. Oracles can therefore be thought of as a mechanism for bridging the gap between the off-chain world and smart contracts. Allowing smart contracts to enforce contractual relationships based on real-world events and data broadens their scope dramatically. However, this can also introduce external risks to Ethereum's security model. Consider a "smart will" contract that distributes assets when a person dies. This is something frequently discussed in the smart contract space, and highlights the risks of a trusted oracle. If the inheritance amount controlled by such a contract is high enough, the incentive to hack the oracle and trigger distribution of assets _before_ the owner dies is very high.

오라클은 이상적으로는 축구 경기 결과, 금 가격 또는 진정한 임의의 결과와 같은 외부 정보 (예 : "리 월드"또는 오프 체인)를 얻는 신뢰할 필요 없는 (또는 적어도 거의 신뢰할 필요 없는) 방법을 제공합니다. 스마트 계약을 위해 이더리움 플랫폼에 또한 데이터를 DApp frontends에 직접 안전하게 relay하는 데 사용할 수도 있습니다. 따라서 오라클은 오프 체인 세계와 스마트 계약 간의 격차를 해소하는 메커니즘으로 생각할 수 있습니다. 스마트 계약이 실제 이벤트 및 데이터를 기반으로 계약 관계를 시행하도록 허용하면 범위가 크게 넓어집니다. 그러나 이로 인해 이더리움 보안 모델에 외부 위험이 발생할 수 있습니다. 사람이 사망할 때 자산을 분배하는 "스마트 윌 (smart will)"계약을 고려해봅시다. 이는 스마트 게약 분야에서 자주 논의되는 내용이며 신뢰할 수있는 오라클의 위험을 강조합니다. 그러한 계약에 의해 통제되는 상속 금액이 충분히 높으면, 소유자가 죽기 전에 오라클을 해킹하고 자산 분배를 유발하는 인센티브가 매우 높습니다.

Note that some oracles provide data that is particular to a specific private data source, such as academic certificates or government IDs. The source of such data, such as a university or government department, is fully trusted, and the truth of the data is subjective (truth is only determined by appeal to the authority of the source). Such data cannot therefore be provided trustlessly—i.e., without  trusting a source—as there is no independently verifiably objective truth. As such, we include these data sources in our definition of what counts as "oracles" because they also provide a data bridge for smart contracts. The data they provide generally takes the form of attestations, such as passports or records of achievement. Attestations will become a big part of the success of blockchain platforms in the future, particularly in relation to the related issues of verifying identity or reputation, so it is important to explore how they can be served by blockchain platforms.

일부 oracles는 학술 인증서 또는 정부 ID와 같은 특정 개인 데이터 소스에 특정한 데이터를 제공합니다. 대학이나 정부 부서와 같은 이러한 데이터의 출처는 전적으로 신뢰되며 데이터의 진실성은 주관적입니다 (진실은 출처의 권위에 대한 호소에 의해서만 결정됩니다). 따라서 독립적으로 검증 가능한 객관적인 진실이 없기 때문에 이러한 데이터는 trustless하게(즉, 출처를 신뢰하지 않고) 제공 할 수 없습니다. 따라서 스마트 계약을 위한 데이터 브리지를 제공하기 때문에 이러한 데이터 source를 "오라클"로 간주되는 정의에 포함합니다. 그들이 제공하는 데이터는 일반적으로 여권 또는 성취 기록과 같은 증명 형식을 취합니다. 증명은 미래의 블록 체인 플랫폼 성공의 큰 부분이 될 것입니다. 특히 신원 또는 명성을 확인하는 관련 문제와 관련하여 블록 체인 플랫폼에 의해 어떻게 제공될 수 있는지 탐구하는 것이 중요합니다.

Some more examples of data that might be provided by oracles include:

* Random numbers/entropy from physical sources such as quantum/thermal processes: e.g., to fairly select a winner in a lottery smart contract
* Parametric triggers indexed to natural hazards: e.g., triggering of catastrophe bond smart contracts, such as Richter scale measurements for an earthquake bond
* Exchange rate data: e.g., for accurate pegging of cryptocurrencies to fiat currency
* Capital markets data: e.g., pricing baskets of tokenized assets/securities
* Benchmark reference data: e.g., incorporating interest rates into smart financial derivatives
* Static/pseudostatic data: security identifiers, country codes, currency codes, etc.
* Time and interval data: for event triggers grounded in precise time measurements
* Weather data: e.g., insurance premium calculations based on weather forecasts
* Political events: for prediction market resolution
* Sporting events: for prediction market resolution and fantasy sports contracts
* Geolocation data: e.g., as used in supply chain tracking
* Damage verification: for insurance contracts
* Events occurring on other blockchains: interoperability functions
* Ether market price: e.g., for fiat gas price oracles
* Flight statistics: e.g., as used by groups and clubs for flight ticket pooling

* 양자 / 열 프로세스와 같은 물리적 소스의 난수 / 엔트로피 : 예를 들어, 복권 스마트 계약에서 승자를 공정하게 선택
* 자연 재해에 대한 지표 트리거 : 예 : 지진 채권에 대한 리히터 규모 측정과 같은 재난 채권 스마트 계약의 트리거
* 환율 데이터 : 예를 들어, 암호 화폐를 법정 통화로 정확하게 페깅하기 위해
* 자본 시장 데이터 : 예 : 토큰 화 된 자산 / 증권의 가격 바구니
* 벤치 마크 참조 데이터 : 예 : 금리를 스마트 금융 파생 상품에 통합
* 정적 / 의사 정적 데이터 : 보안 식별자, 국가 코드, 통화 코드 등
* 시간 및 간격 데이터 : 정확한 시간 측정에 기반한 이벤트 트리거 용
* 날씨 데이터 : 날씨 예보를 기반으로 한 보험료 계산
* 정치 이벤트 : 시장 예측 예측
* 스포츠 이벤트 : 예측 시장 해결 및 판타지 스포츠 계약
* 지리적 위치 데이터 : 예 : 공급망 추적에 사용
* 손상 검증 : 보험 계약
* 다른 블록 체인에서 발생하는 이벤트 : 상호 운용성 기능
* 에테르 시장 가격 : 예를 들어 피아트 가스 가격 오라클
* 비행 통계 : 예 : 그룹 및 클럽에서 항공권 풀링에 사용

In the following sections, we will examine some of the ways oracles can be implemented, including basic oracle patterns, computation oracles, decentralized oracles, and oracle client implementations in Solidity.

[[oracle_design_patterns]]
=== Oracle Design Patterns

((("oracles","design patterns", id="ix_11oracles-asciidoc1", range="startofrange")))All oracles provide a few key functions, by definition. These include the ability to:

모든 오라클은 정의에 따라 몇 가지 주요 기능을 제공합니다. 여기에는 다음과 같은 기능이 포함됩니다.

* Collect data from an off-chain source.
* Transfer the data on-chain with a signed message.
* Make the data available by putting it in a smart contract's storage.

* 오프 체인 소스에서 데이터를 수집하십시오.
* 서명 된 메시지와 함께 온 체인 데이터를 전송하십시오.
* 스마트 컨트랙트 저장소에 저장하여 데이터를 사용할 수 있게하십시오.

Once the data is available in a smart contract's storage, it can be accessed by other smart contracts via message calls that invoke a "retrieve" function of the oracle's smart contract; it can also be accessed by Ethereum nodes or network-enabled clients directly by "looking into&#x201d; the oracle's storage.

The three main ways to set up an oracle can be categorized as _request–response_, pass:[<span class="keep-together"><em>publish-subscribe</em></span>], and _immediate-read_.

스마트 계약의 스토리지에서 데이터를 사용할 수있게되면 오라클 스마트 계약의 "검색"기능을 호출하는 메시지 호출을 통해 다른 스마트 계약에 의해 데이터에 액세스 할 수 있습니다. 또한 이더리움 노드 또는 네트워크 지원 클라이언트가 오라클 스토리지를 "보고"직접 액세스하여 액세스 할 수도 있습니다.

오라클을 설정하는 세 가지 주요 방법은 요청-응답, 발행-구독 및 즉시 읽기로 분류 할 수 있습니다.

((("immediate-read oracles")))((("oracles","immediate-read")))Starting with the simplest, _immediate-read_ oracles are those that provide data that is only needed for an immediate decision, like "What is the address for __ethereumbook.info__?" or "Is this person over 18?" Those wishing to query this kind of data tend to do so on a "just-in-time" basis; the lookup is done when the information is needed and possibly never again. Examples of such oracles include those that hold data about or issued by organizations, such as academic certificates, dial codes, institutional memberships, airport identifiers, self-sovereign IDs, etc. This type of oracle stores data once in its contract storage, whence any other smart contract can look it up using a request call to the oracle contract. It may be updated. The data in the oracle's storage is also available for direct lookup by blockchain-enabled (i.e., Ethereum pass:[<span class="keep-together">client–connected</span>]) applications without having to go through the palaver and incurring the gas costs of issuing a transaction. A shop wanting to check the age of a customer wishing to purchase alcohol could use an oracle in this way. This type of oracle is attractive to an organization or company that might otherwise have to run and maintain servers to answer such data requests. Note that the data stored by the oracle is likely not to be the raw data that the oracle is serving, e.g., for efficiency or privacy reasons. A university might set up an oracle for the certificates of academic achievement of past students. However, storing the full details of the certificates (which could run to pages of courses taken and grades achieved) would be excessive. Instead, a hash of the certificate is sufficient. Likewise, a government might wish to put citizen IDs onto the Ethereum platform, where clearly the details included need to be kept private. Again, hashing the data (more carefully, in Merkle trees with salts) and only storing the root hash in the smart contract's storage would be an efficient way to organize such a service.

가장 간단하고 즉시 읽을 수 있는 오라클은 "ethereumbook.info의 주소는 무엇입니까?"와 같이 즉각적인 결정에만 필요한 데이터를 제공하는 오라클입니다. 또는 "이 사람이 18 세 이상입니까?" 이런 종류의 데이터를 쿼리하려는 사람들은 "적시에"이를 수행하는 경향이 있습니다. 정보가 필요할 때 그리고 다시는 불가능할 때 조회(lookup)가 수행됩니다. 이러한 오라클의 예로는 학술 인증서, 다이얼 코드, 기관 멤버십, 공항 식별자, 자치권 ID 등과 같은 조직에 대한 데이터를 보유하거나 발행한 것들이 있습니다. 이러한 유형의 오라클은 계약 저장소에 데이터를 한 번 저장합니다. 다른 스마트 계약은 오라클 계약에 대한 요청 호출을 사용하여 찾을 수 있습니다. 업데이트 될 수 있습니다. 오라클 스토리지의 데이터는 palaver를 거치지 않고 transaction 발행의 gas 비용을 들이지 않고도 blockchain-enabled (즉, 이더리움 client-connected) 애플리케이션을 통해 직접 조회할 수 있습니다. 주류 구매를 원하는 고객의 연령을 확인하려는 상점에서는 이러한 방식으로 오라클을 사용할 수 있습니다. 이러한 유형의 오라클은 이러한 데이터 요청에 응답하기 위해 서버를 실행하고 유지 관리해야하는 조직이나 회사에 적합합니다. 오라클이 저장한 데이터는 예를 들어 효율성 또는 개인 정보 보호를 위해 오라클이 제공하는 원시 데이터가 아닐 수 있습니다. 대학은 과거 학생들의 학업 성취 증명서를위한 오라클을 설정할 수 있습니다. 그러나 인증서의 전체 세부 정보를 저장하면 (수강 과정 및 성적 페이지로 이어질 수 있음) 과도합니다. 대신 인증서 해시로 충분합니다. 마찬가지로 정부는 시민 신분증을 이더 리움 플랫폼에 넣기를 원할 수 있으며, 여기에 포함된 세부 사항을 분명히 비공개로 유지해야합니다. 다시 말하지만, 데이터를 해시하고 (more carefully, in Merkle trees with salts) 스마트 계약 저장소에 루트 해시 만 저장하면 이러한 서비스를 효율적으로 구성 할 수 있습니다.

((("oracles","publish-subscribe")))((("publish-subscribe oracles")))The next setup is _publish–subscribe_, where an oracle that effectively provides a broadcast service for data that is expected to change (perhaps both regularly and frequently) is either polled by a smart contract on-chain, or watched by an off-chain daemon for updates. This category has a pattern similar to RSS feeds, WebSub, and the like, where the oracle is updated with new information and a flag signals that new data is available to those who consider themselves "subscribed." Interested parties must either poll the oracle to check whether the latest information has changed, or listen for updates to oracle contracts and act when they occur. Examples include price feeds, weather information, economic or social statistics, traffic data, etc. Polling is very inefficient in the world of web servers, but not so in the peer-to-peer context of blockchain platforms: Ethereum clients have to keep up with all state changes, including changes to contract storage, so polling for data changes is a local call to a synced client. Ethereum event logs make it particularly easy for applications to look out for oracle updates, and so this pattern can in some ways even be considered a "push" service. However, if the polling is done from a smart contract, which might be necessary for some decentralized applications (e.g., where activation incentives are not possible), then significant gas expenditure may be incurred.

다음 설정은 publish-subscribe입니다. 여기서 정기적으로 자주 변경 될 것으로 예상되는 데이터에 대해 broadcast 서비스를 효과적으로 제공하는 오라클은 스마트 계약 온 체인(on-chain)으로 poll되거나 업데이트를 위해 off-chain daemon으로 감시됩니다. 이 범주에는 RSS 피드, WebSub 등과 유사한 패턴이 있으며, 여기서 오라클은 새로운 정보로 업데이트되며 플래그는 "구독된"것으로 간주되는 사람들이 새로운 데이터를 사용할 수 있음을 나타냅니다. 관심있는 당사자는 최신 정보가 변경되었는지 여부를 확인하기 위해 Oracle을 poll하거나, listen for updates to oracle contracts and act when they occur해야 합니다. 예를 들어 가격 피드, 날씨 정보, 경제 또는 사회 통계, 교통 데이터 등이 있습니다. 폴링은 웹 서버 세계에서 매우 비효율적이지만 블록 체인 플랫폼의 peer-to-peer 컨텍스트에서는 그렇지 않습니다. Ethereum clients have to keep up with all state changes, including changes to contract storage, so polling for data changes is a local call to a synced client. 이더리움 이벤트 로그를 사용하면 응용 프로그램에서 Oracle 업데이트를 쉽게 찾을 수 있으므로이 패턴을 "푸시" 서비스로 간주 할 수도 있습니다. 그러나 일부 분산 응용 프로그램(예 : activation incentives가 불가능한 경우)에 필요할 수있는 스마트 계약에서 폴링을 수행하면 상당한 가스 소비가 발생할 수 있습니다.

((("oracles","request-response")))((("request-response oracles")))The _request–response_ category is the most complicated: this is where the data space is too huge to be stored in a smart contract and users are expected to only need a small part of the overall dataset at a time. It is also an applicable model for data provider businesses. In practical terms, such an oracle might be implemented as a system of on-chain smart contracts and off-chain infrastructure used to monitor requests and retrieve and return data. A request for data from a decentralized application would typically be an asynchronous process involving a number of steps. In this pattern, firstly, an EOA transacts with a decentralized application, resulting in an interaction with a function defined in the oracle smart contract. This function initiates the request to the oracle, with the associated arguments detailing the data requested in addition to supplementary information that might include callback functions and scheduling parameters. Once this transaction has been validated, the oracle request can be observed as an EVM event emitted by the oracle contract, or as a state change; the arguments can be retrieved and used to perform the actual query of the off-chain data source. The oracle may also require payment for processing the request, gas payment for the callback, and permissions to access the requested data. Finally, the resulting data is signed by the oracle owner, attesting to the validity of the data at a given time, and delivered in a transaction to the decentralized application that made the request—either directly or via the oracle contract. Depending on the scheduling parameters, the oracle may broadcast further transactions updating the data at regular intervals (e.g., end-of-day pricing information).

요청-응답 범주는 가장 복잡합니다. 데이터 공간이 너무 커서 스마트 계약에 저장하기 어렵고 사용자는 한 번에 전체 데이터 집합의 일부만 필요로합니다. 또한 데이터 제공 업체 비즈니스에 적용 가능한 모델입니다. 실제로 이러한 오라클은 요청을 모니터링하고 데이터를 검색 및 반환하는 데 사용되는 on-chain 스마트 계약 및 off-chain 인프라 시스템으로 구현 될 수 있습니다. 분산 응용 프로그램의 데이터 요청은 일반적으로 여러 단계를 포함하는 asynchronous 프로세스입니다. 이 패턴에서 먼저 EOA는 분산 응용 프로그램과 거래하여 Oracle 스마트 계약에 정의 된 기능과 상호 작용합니다. 이 함수는 콜백 함수 및 스케줄링 파라메터를 include할 수 있는 보충 정보 외에 요청된 데이터를 자세히 설명하는 관련 argument들과 함께 오라클에 대한 요청을 initiate합니다. 이 트랜잭션이 확인되면 Oracle 요청은 Oracle 계약에 의해 생성 된 EVM 이벤트 또는 상태 변경으로 관찰 될 수 있습니다. 인수를 검색하여 off-chain 데이터 소스의 실제 쿼리를 수행하는 데 사용할 수 있습니다. 또한 오라클은 요청을 처리하기위한 지불, callback을 위한 gas 지불 및 요청 된 데이터에 대한 액세스 권한을 요구할 수 있습니다. 마지막으로 결과 데이터는 오라클 소유자가 서명 한 후 주어진 시간에 데이터의 유효성을 증명하고 직접 또는 오라클 계약을 통해 요청을 한 분산 응용 프로그램으로 트랜잭션으로 전달됩니다. 스케줄링 파라미터에 따라, 오라클은 규칙적인 간격 (예를 들어, 종말 가격 정보)으로 데이터를 업데이트하는 추가 트랜잭션을 broadcast할 수있습니다.

The steps for a request–response oracle may be summarized as follows:

1. Receive a query from a DApp.
2. Parse the query.
3. Check that payment and data access permissions are provided.
4. Retrieve relevant data from an off-chain source (and encrypt it if necessary).
5. Sign the transaction(s) with the data included.
6. Broadcast the transaction(s) to the network.
7. Schedule any further necessary transactions, such as notifications, etc.

1. DApp에서 쿼리를받습니다.
2. 쿼리를 구문 분석하십시오.
3. 지불 및 데이터 액세스 권한이 제공되는지 확인하십시오.
4. 오프 체인 소스에서 관련 데이터를 검색하고 필요한 경우 암호화합니다.
5. 포함 된 데이터로 거래에 서명하십시오.
6. 트랜잭션을 네트워크에 브로드 캐스트하십시오.
7. 알림 등과 같은 추가로 필요한 거래를 예약합니다.

A range of other schemes are also possible; for example, data can be requested from and returned directly by an EOA, removing the need for an oracle smart contract. Similarly, the request and response could be made to and from an Internet of Things–enabled hardware sensor. Therefore, oracles can be human, software, or hardware.

The request–response pattern described here is commonly seen in client–server architectures. While this is a useful messaging pattern that allows applications to have a two-way conversation, it is perhaps inappropriate under certain conditions. For example, a smart bond requiring an interest rate from an oracle might have to request the data on a daily basis under a request–response pattern in order to ensure the rate is always correct. Given that interest rates change infrequently, a publish–subscribe pattern may be more appropriate here—especially when taking into consideration Ethereum's limited bandwidth.

다양한 다른 방식들도 가능합니다; 예를 들어 EOA에서 직접 데이터를 요청하고 반환 할 수 있다면 Oracle 스마트 계약이 필요하지 않습니다. 이와 유사하게, IoT 하드웨어 센서에 대한 요청 및 응답이 이루어질 수 있습니다. 따라서 오라클은 사람, 소프트웨어 또는 하드웨어 일 수 있습니다.

여기에 설명 된 요청-응답 패턴은 일반적으로 클라이언트-서버 아키텍처에서 볼 수 있습니다. 응용 프로그램이 양방향 대화를 할 수있는 유용한 메시징 패턴이지만 특정 조건에서는 적합하지 않을 수 있습니다. 예를 들어, 오라클의 이자율이 필요한 스마트 본드는 이자율이 항상 정확한지 확인하기 위해 요청-응답 패턴으로 매일 데이터를 요청해야 할 수 있습니다. 이자율이 드물게 변경되는 경우, 특히 이더리움의 제한된 대역폭을 고려할 때 발행-구독 패턴이 더 적합 할 수 있습니다.

Publish–subscribe is a pattern where publishers (in this context, oracles) do not send messages directly to receivers, but instead categorize published messages into distinct classes. Subscribers are able to express an interest in one or more classes and retrieve only those messages that are of interest. Under such a pattern, an oracle might write the interest rate to its own internal storage each time it changes. Multiple subscribed DApps can simply read it from the oracle contract, thereby reducing the impact on network bandwidth while minimizing storage costs.

((("broadcast (multicast) oracle")))((("multicast (broadcast) oracle")))((("oracles","broadcast/multicast")))In a broadcast or multicast pattern, an oracle would post all messages to a channel and subscribing contracts would listen to the channel under a variety of subscription modes. For example, an oracle might publish messages to a cryptocurrency exchange rate channel. A subscribing smart contract could request the full content of the channel if it required the time series for, e.g., a moving average calculation; another might require only the latest rate for a spot price calculation. A broadcast pattern is appropriate where the oracle does not need to know the identity of the subscribing pass:[<span class="keep-together">contract</span>].(((range="endofrange", startref="ix_11oracles-asciidoc1")))

게시-구독은 게시자(이 맥락에서 oracles)가 메시지를 수신자에게 직접 보내지 않고 게시된 메시지를 별개의 클래스로 분류하는 패턴입니다. 가입자는 하나 이상의 클래스에 관심을 표명하고 관심있는 메시지만 검색 할 수 있습니다. 이러한 패턴에서 오라클은 변경 될 때마다 이자율을 자체 내부 스토리지에 쓸 수 있습니다. 구독한 여러 DApp은 오라클 계약에서 간단히 읽을 수 있으므로 스토리지 대역폭을 최소화하면서 네트워크 대역폭에 미치는 영향을 줄일 수 있습니다. 브로드 캐스트 또는 멀티 캐스트 패턴에서 오라클은 모든 메시지를 채널에 게시하고 구독 계약은 다양한 구독 모드에서 채널을 청취합니다. 예를 들어, 오라클은 암호 화폐 환율 채널에 메시지를 게시 할 수 있습니다. 구독 스마트 계약은 예를 들어 이동 평균 계산에 시계열이 필요한 경우 채널의 전체 콘텐츠를 요청할 수 있습니다. 다른 하나는 현물 가격 계산에 최신 rate만 필요할 수 있습니다. 오라클이 subscribing 컨트랙트의 신원을 알 필요가 없는 경우 브로드 캐스트 패턴이 적합합니다.

[[data_authentication_sec]]
=== Data Authentication

((("data authentication, oracles and")))((("oracles","and data authentication")))((("oracles","data authentication with")))If we assume that the source of data being queried by a DApp is both authoritative and trustworthy (a not insignificant assumption), an outstanding question remains: given that the oracle and the request–response mechanism may be operated by distinct entities, how are we able trust this mechanism? There is a distinct possibility that data may be tampered with in transit, so it is critical that off-chain methods are able to attest to the returned data's integrity. Two common approaches to data authentication are _authenticity proofs_ and _trusted execution environments_ (TEEs).

((("authenticity proofs")))Authenticity proofs are cryptographic guarantees that data has not been tampered with. Based on a variety of attestation techniques (e.g., digitally signed proofs), they effectively shift the trust from the data carrier to the attestor (i.e., the provider of the attestation). By verifying the authenticity proof on-chain, smart contracts are able to verify the integrity of the data before operating upon it. ((("Oraclize")))http://www.oraclize.it/[Oraclize] is an example of an oracle service leveraging a variety of authenticity proofs. ((("TLSNotary proofs")))One such proof that is currently available for data queries from the Ethereum main network is the TLSNotary proof. TLSNotary proofs allow a client to provide evidence to a third party that HTTPS web traffic occurred between the client and a server. While HTTPS is itself secure, it doesn’t support data signing. As a result, TLSNotary proofs rely on TLSNotary (via PageSigner) signatures. TLSNotary proofs leverage the Transport Layer Security (TLS) protocol, enabling the TLS master key, which signs the data after it has been accessed, to be split between three parties: the server (the oracle), an auditee (Oraclize), and an auditor. Oraclize uses an Amazon Web Services (AWS) virtual machine instance as the auditor, which can be verified as having been unmodified since instantiation. This AWS instance stores the TLSNotary secret, allowing it to provide honesty proofs. Although it offers higher assurances against data tampering than a pure request–response mechanism, this approach does require the assumption that Amazon itself will not tamper with the VM instance.

DApp에 의해 쿼리되는 데이터 소스가 autoritiative이고 신뢰할만한 가치가 있다고 가정 할 경우 (무의미한 가정은 아님) 오라클과 요청-응답 메커니즘이 별개의 엔티티에 의해 운영 될 수 있다는 점에서 아직 의문의 여지가 남아 있습니다. 이 메커니즘을 신뢰할 수 있습니까? 전송 중에 데이터가 훼손 될 가능성이 있으므로 오프 체인 방식이 반환된 데이터의 무결성을 증명할 수 있어야합니다. 데이터 인증에 대한 두 가지 일반적인 접근 방식은 진위 증명과 신뢰할 수있는 실행 환경 (TEE)입니다.

진위 증명은 데이터가 변조되지 않았다는 암호화 보증입니다. 다양한 증명 기술 (예 : 디지털 서명 된 증명)을 기반으로 데이터 캐리어에서 입증 인 (즉, 인증 제공자)에게 신뢰를 효과적으로 이동시킵니다. 스마트 계약은 체인에서 authenticity proof on-chain을 검증함으로써 데이터의 무결성을 검증 할 수 있습니다. Oraclize는 다양한 진위 증명을 활용하는 Oracle 서비스의 예입니다. 현재 이더 리움 메인 네트워크에서 데이터 쿼리에 사용할 수있는 그러한 증거 중 하나는 TLSNotary 증거입니다. TLSNotary 증명을 통해 클라이언트는 클라이언트와 서버간에 HTTPS 웹 트래픽이 발생했다는 증거를 타사에 제공 할 수 있습니다. HTTPS 자체는 안전하지만 데이터 서명을 지원하지 않습니다. 결과적으로 TLSNotary 증명은 PageSigner를 통한 TLSNotary 서명에 의존합니다. TLSNotary 증명은 TLS (Transport Layer Security) 프로토콜을 활용하여 액세스 한 후 데이터에 서명하는 TLS 마스터 키를 서버 (Oracle), 피 감사 인 (Oraclize) 및 감사. Oraclize는 AWS (Amazon Web Services) 가상 머신 인스턴스를 감사 자로 사용하며, 인스턴스화 이후 수정되지 않은 것으로 확인할 수 있습니다. 이 AWS 인스턴스는 TLSNotary 비밀을 저장하여 정직한 증거를 제공 할 수 있습니다. 순수한 요청-응답 메커니즘보다 데이터 변조에 대해 더 높은 보증을 제공하지만이 방법을 사용하려면 Amazon 자체가 VM 인스턴스를 변경하지 않을 것이라는 가정이 필요합니다.

((("TEEs (trusted execution environments)")))((("Town Crier")))((("trusted execution environments (TEEs)")))http://www.town-crier.org/[Town Crier] is an authenticated data feed oracle system based on the TEE approach; such methods utilize hardware-based secure enclaves to ensure data integrity. Town Crier uses Intel's  ((("SGX (Software Guard eXtensions)")))((("Software Guard eXtensions (SGX)")))Software Guard eXtensions (SGX) to ensure that responses from HTTPS queries can be verified as authentic. SGX provides guarantees of integrity, ensuring that applications running within an enclave are protected by the CPU against tampering by any other process. It also provides confidentiality, ensuring that an application's state is opaque to other processes when running within the enclave. And finally, SGX allows attestation, by generating a digitally signed proof that an application—securely identified by a hash of its build—is actually running within an enclave. By verifying this digital signature, it is possible for a decentralized application to prove that a Town Crier instance is running securely within an SGX enclave. This, in turn, proves that the instance has not been tampered with and that the data emitted by Town Crier is therefore authentic. The confidentiality property additionally enables Town Crier to handle private data by allowing data queries to be encrypted using the Town Crier instance's public key. Operating an oracle's query/response mechanism within an enclave such as SGX effectively allows us to think of it as running securely on trusted third-party hardware, ensuring that the requested data is returned untampered with (assuming that we trust Intel/SGX).

Town Crier는 TEE 접근 방식을 기반으로 인증된 데이터 피드 오라클 시스템입니다. 이러한 방법은 하드웨어 기반 보안 enclaves를 사용하여 데이터 무결성을 보장합니다. Town Crier는 인텔의 SGX (Software Guard eXtensions)를 사용하여 HTTPS 쿼리의 응답을 확실한 것으로 확인할 수 있습니다. SGX는 무결성 보장을 제공하여 enclaves 내에서 실행중인 응용 프로그램이 다른 프로세스의 조작에 대해 CPU에 의해 보호되도록합니다. 또한 기밀 유지 기능을 제공하여 enclaves 내에서 실행될 때 응용 프로그램의 상태가 다른 프로세스에 대해 불투명하도록합니다. 마지막으로 SGX는 빌드의 해시로 안전하게 식별 된 애플리케이션이 실제로 enclaves 내에서 실행되고 있다는 디지털 서명 된 증거를 생성함으로써 증명을 허용합니다. 이 디지털 서명을 확인하면 분산 응용 프로그램에서 Town Crier 인스턴스가 SGX 엔 클레이브 내에서 안전하게 실행되고 있음을 증명할 수 있습니다. 이는 인스턴스가 변경되지 않았으므로 Town Crier가 생성 한 데이터가 정품임을 나타냅니다. 또한 기밀 속성을 통해 Town Crier는 Town Crier 인스턴스의 공개 키를 사용하여 데이터 쿼리를 암호화함으로써 개인 데이터를 처리 할 수 있습니다. SGX와 같은 엔 클레이브 내에서 오라클의 쿼리 / 응답 메커니즘을 운영하면 신뢰할 수있는 타사 하드웨어에서이를 안전하게 실행하는 것으로 효과적으로 생각할 수 있으므로 요청 된 데이터가 변경되지 않고 반환됩니다 (Intel / SGX를 신뢰한다고 가정).

[[computation_oracles_sec]]
=== Computation Oracles

((("oracles","computation oracles", id="ix_11oracles-asciidoc2", range="startofrange")))So far, we have only discussed oracles in the context of requesting and delivering data. However, oracles can also be used to perform arbitrary computation, a function that can be especially useful given Ethereum’s inherent block gas limit and comparatively expensive computation costs. Rather than just relaying the results of a query, computation oracles can be used to perform computation on a set of inputs and return a calculated result that may have been infeasible to calculate on-chain. For example, one might use a computation oracle to perform a computationally intensive regression calculation in order to estimate the yield of a bond contract.

((("Oraclize")))If you are willing to trust a centralized but auditable service, you can go again to Oraclize. They provide a service that allows decentralized applications to request the output of a computation performed in a sandboxed AWS virtual machine. The AWS instance creates an executable container from a user-configured Dockerfile packed in an archive that is uploaded to the Inter-Planetary File System (IPFS; see <<data_storage_sec>>). On request, Oraclize retrieves this archive using its hash and then initializes and executes the Docker container on AWS, passing any arguments that are provided to the application as environment variables. The containerized application performs the calculation, subject to a time constraint, and writes the result to standard output, where it can be retrieved by Oraclize and returned to the decentralized application. Oraclize currently offers this service on an auditable t2.micro AWS instance, so if the computation is of some nontrivial value, it is possible to check that the correct Docker container was executed. Nonetheless, this is not a truly decentralized solution.

지금까지 우리는 데이터를 요청하고 전달하는 맥락에서 오라클에 대해서만 논의했습니다. 그러나, oracles는 Ethereum 고유의 블록 가스 제한과 비교적 비싼 계산 비용을 고려할 때 특히 유용한 기능인 arbitrary 계산을 수행하는 데 사용될 수도 있습니다. 쿼리 결과를 relay하는 대신, 계산 오라클을 사용하여 일련의 입력에 대해 계산을 수행하고 온 체인을 계산하는 것이 불가능했을 수있는 계산 된 결과를 반환 할 수 있습니다. 예를 들어, 채권 계약의 수익률을 추정하기 위해 계산 오라클을 사용하여 계산 집약적인 회귀 계산을 수행 할 수 있습니다.

중앙 집중식이지만 감사 가능한 서비스를 기꺼이 신뢰한다면 Oraclize로 다시 갈 수 있습니다. 분산된 애플리케이션이 샌드 박스 AWS 가상 머신에서 수행된 계산의 출력을 요청할 수있는 서비스를 제공합니다. AWS 인스턴스는 IPS (Inter-Planetary File System)에 업로드 된 아카이브에 압축된 사용자 구성 Dockerfile에서 실행 가능 컨테이너를 생성합니다 ([data_storage_sec] 참조). 요청시 Oraclize는 해시를 사용하여 이 아카이브를 검색한 다음 애플리케이션 변수를 환경 변수로 제공하는 인수를 전달하여 AWS에서 Docker 컨테이너를 초기화하고 실행합니다. 컨테이너화된 응용 프로그램은 시간 제약 조건에 따라 계산을 수행하고 그 결과를 표준 출력에 기록하며 Oraclize에서 검색하여 분산 응용 프로그램으로 반환 할 수 있습니다. Oraclize는 현재 감사 가능한 t2.micro AWS 인스턴스에서이 서비스를 제공하므로 계산이 중요하지 않은 경우 올바른 Docker 컨테이너가 실행되었는지 확인할 수 있습니다. 그럼에도 불구하고 이것은 진정한 분산 솔루션이 아닙니다.

((("cryplet")))The concept of a 'cryptlet' as a standard for verifiable oracle truths has been formalized as part of Microsoft's wider ESC Framework.  Cryptlets execute within an encrypted capsule that abstracts away the infrastructure, such as I/O, and has the CryptoDelegate attached so incoming and outgoing messages are signed, validated, and proven automatically.  Cryptlets support distributed transactions so that contract logic can take on complex multistep, multiblockchain, and external system transactions in an ACID manner.  This allows developers to create portable, isolated, and private resolutions of the truth for use in smart contracts. Cryptlets follow the format shown here:

[source,solidity]
----
public class SampleContractCryptlet : Cryptlet
  {
        public SampleContractCryptlet(Guid id, Guid bindingId, string name,
            string address, IContainerServices hostContainer, bool contract)
            : base(id, bindingId, name, address, hostContainer, contract)
        {
            MessageApi = new CryptletMessageApi(GetType().FullName,
                new SampleContractConstructor())
----

((("TrueBit")))For a more decentralized solution, we can turn to https://truebit.io/[TrueBit], which offers a solution for scalable and verifiable off-chain computation. They use a system of solvers and verifiers who are incentivized to perform computations and verification of those computations, respectively. Should a solution be challenged, an iterative verification process on subsets of the computation is performed on-chain—a kind of 'verification game'. The game proceeds through a series of rounds, each recursively checking a smaller and smaller subset of the computation. The game eventually reaches a final round, where the challenge is sufficiently trivial such that the judges—Ethereum miners—can make a final ruling on whether the challenge was met, on-chain. In effect, TrueBit is an implementation of a computation market, allowing decentralized applications to pay for verifiable computation to be performed outside of the network, but relying on Ethereum to enforce the rules of the verification game. In theory, this enables trustless smart contracts to securely perform any computation task.

A broad range of applications exist for systems like TrueBit, ranging from machine learning to verification of proof of work. An example of the latter is the Doge–Ethereum bridge, which uses TrueBit to verify Dogecoin’s proof of work (Scrypt), which is a memory-hard and computationally intensive function that cannot be computed within the Ethereum block gas limit. By performing this verification on TrueBit, it has been possible to securely verify Dogecoin transactions within a smart contract on Ethereum's Rinkeby testnet.(((range="endofrange", startref="ix_11oracles-asciidoc2")))

[[decentralized_orackes_sec]]
=== Decentralized Oracles

((("oracles","decentralized")))While centralized data or computation oracles suffice for many applications, they represent single points of failure in the Ethereum network. A number of schemes have been proposed around the idea of decentralized oracles as a means of ensuring data availability and the creation of a network of individual data providers with an on-chain data aggregation system.

((("ChainLink")))https://www.smartcontract.com/link[ChainLink] has proposed a decentralized oracle network consisting of three key smart contracts&#x2014;a reputation contract, an order-matching contract, and an aggregation contract&#x2014;and an off-chain registry of data providers. The reputation contract is used to keep track of data providers' performance. Scores in the reputation contract are used to populate the off-chain registry. The order-matching contract selects bids from oracles using the reputation contract. It then finalizes a service-level agreement, which includes query parameters and the number of oracles required. This means that the purchaser needn’t transact with the individual oracles directly. The aggregation contract collects responses (submitted using a commit–reveal scheme) from multiple oracles, calculates the final collective result of the query, and finally feeds the results back into the reputation contract.

One of the main challenges with such a decentralized approach is the formulation of the aggregation function. ChainLink proposes calculating a weighted response, allowing a validity score to be reported for each oracle response. Detecting an 'invalid' score here is nontrivial, since it relies on the premise that outlying data points, measured by deviations from responses provided by peers, are incorrect. Calculating a validity score based on the location of an oracle response among a distribution of responses risks penalizing correct answers over average ones. Therefore, ChainLink offers a standard set of aggregation contracts, but also allows customized aggregation contracts to be specified.

((("SchellingCoin protocol")))A related idea is the SchellingCoin protocol. Here, multiple participants report values and the median is taken as the &#x201c;correct&#x201d; answer. Reporters are required to provide a deposit that is redistributed in favor of values that are closer to the median, therefore incentivizing the reporting of values that are similar to others. A common value, also known as the Schelling point, which respondents might consider as the natural and obvious target around which to coordinate is expected to be close to the actual value.

Jason Teutsch of TrueBit recently proposed a new design for a decentralized off-chain data availability oracle. This design leverages a dedicated proof-of-work blockchain that is able to correctly report on whether or not registered data is available during a given epoch. Miners attempt to download, store, and propagate all currently registered data, thereby guaranteeing data is available locally. While such a system is expensive in the sense that every mining node stores and propagates all registered data, the system allows storage to be reused by releasing data after the registration period ends.

[[oracle_client_interfaces_in_solidity_sec]]
=== Oracle Client Interfaces in Solidity

((("oracles","client interfaces in Solidity", id="ix_11oracles-asciidoc3", range="startofrange")))((("Oraclize", id="ix_11oracles-asciidoc4", range="startofrange")))((("Solidity","oracle client interfaces in", id="ix_11oracles-asciidoc5", range="startofrange")))<<using_oraclize_to_update_the_eth_usd>> is a Solidity example demonstrating how Oraclize can be used to continuously poll for the ETH/USD price from an API and store the result in a usable manner.

[[using_oraclize_to_update_the_eth_usd]]
.Using Oraclize to update the ETH/USD exchange rate from an external source
====
[source,solidity]
----
/*
   ETH/USD price ticker leveraging CryptoCompare API

   This contract keeps in storage an updated ETH/USD price,
   which is updated every 10 minutes.
 */

pragma solidity ^0.4.1;
import "github.com/oraclize/ethereum-api/oraclizeAPI.sol";

/*
   "oraclize_" prepended methods indicate inheritance from "usingOraclize"
 */
contract EthUsdPriceTicker is usingOraclize {

    uint public ethUsd;

    event newOraclizeQuery(string description);
    event newCallbackResult(string result);

    function EthUsdPriceTicker() payable {
        // signals TLSN proof generation and storage on IPFS
        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);

        // requests query
        queryTicker();
    }

    function __callback(bytes32 _queryId, string _result, bytes _proof) public {
        if (msg.sender != oraclize_cbAddress()) throw;
        newCallbackResult(_result);

        /*
         * Parse the result string into an unsigned integer for on-chain use.
         * Uses inherited "parseInt" helper from "usingOraclize", allowing for
         * a string result such as "123.45" to be converted to uint 12345.
         */
        ethUsd = parseInt(_result, 2);

        // called from callback since we're polling the price
        queryTicker();
    }

    function queryTicker() public payable {
        if (oraclize_getPrice("URL") > this.balance) {
            newOraclizeQuery("Oraclize query was NOT sent, please add some ETH
                to cover for the query fee");
        } else {
            newOraclizeQuery("Oraclize query was sent, standing by for the
                answer...");

            // query params are (delay in seconds, datasource type,
            // datasource argument)
            // specifies JSONPath, to fetch specific portion of JSON API result
            oraclize_query(60 * 10, "URL",
                "json(https://min-api.cryptocompare.com/data/price?\
                fsym=ETH&tsyms=USD,EUR,GBP).USD");
        }
    }
}
----
====

To integrate with Oraclize, the contract +EthUsdPriceTicker+ must be a child of pass:[<span class="keep-together"><code>usingOraclize</code></span>]; the +usingOraclize+ contract is defined in the _oraclizeAPI_ file. The data request is made using the +oraclize_query+ function, which is inherited from the +usingOraclize+ contract. This is an overloaded function that expects at least two arguments:

* The supported data source to use, such as URL, WolframAlpha, IPFS, or computation
* The argument for the given data source, which may include the use of JSON or XML parsing helpers

The price query is performed in the +queryTicker+ function. In order to perform the query, Oraclize requires the payment of a small fee in ether, covering the gas cost for processing the result and transmitting it to the +pass:[__]callback+ function and an accompanying surcharge for the service. This amount is dependent on the data source and, where specified, the type of authenticity proof that is required. Once the data has been retrieved, the +pass:[__]callback+ function is called by an Oraclize-controlled account permissioned to do the callback; it passes in the response value and a unique +queryId+ argument, which, for example, can be used to handle and track multiple pending callbacks from Oraclize.

((("BlockOne IQ")))Financial data provider Thomson Reuters also provides an oracle service for Ethereum, called BlockOne IQ, allowing market and reference data to be requested by smart contracts running on private or permissioned networks. <<contract_calling_the_blockone_iq_service_for_market_data>> shows the interface for the oracle, and a client contract that will make the request.

[[contract_calling_the_blockone_iq_service_for_market_data]]
.Contract calling the BlockOne IQ service for market data
====
[source,solidity]
----
pragma solidity ^0.4.11;

contract Oracle {
    uint256 public divisor;
    function initRequest(
       uint256 queryType, function(uint256) external onSuccess,
       function(uint256
    ) external onFailure) public returns (uint256 id);
    function addArgumentToRequestUint(uint256 id, bytes32 name, uint256 arg) public;
    function addArgumentToRequestString(uint256 id, bytes32 name, bytes32 arg)
        public;
    function executeRequest(uint256 id) public;
    function getResponseUint(uint256 id, bytes32 name) public constant
        returns(uint256);
    function getResponseString(uint256 id, bytes32 name) public constant
        returns(bytes32);
    function getResponseError(uint256 id) public constant returns(bytes32);
    function deleteResponse(uint256 id) public constant;
}

contract OracleB1IQClient {

    Oracle private oracle;
    event LogError(bytes32 description);

    function OracleB1IQClient(address addr) public payable {
        oracle = Oracle(addr);
        getIntraday("IBM", now);
    }

    function getIntraday(bytes32 ric, uint256 timestamp) public {
        uint256 id = oracle.initRequest(0, this.handleSuccess, this.handleFailure);
        oracle.addArgumentToRequestString(id, "symbol", ric);
        oracle.addArgumentToRequestUint(id, "timestamp", timestamp);
        oracle.executeRequest(id);
    }

    function handleSuccess(uint256 id) public {
        assert(msg.sender == address(oracle));
        bytes32 ric = oracle.getResponseString(id, "symbol");
        uint256 open = oracle.getResponseUint(id, "open");
        uint256 high = oracle.getResponseUint(id, "high");
        uint256 low = oracle.getResponseUint(id, "low");
        uint256 close = oracle.getResponseUint(id, "close");
        uint256 bid = oracle.getResponseUint(id, "bid");
        uint256 ask = oracle.getResponseUint(id, "ask");
        uint256 timestamp = oracle.getResponseUint(id, "timestamp");
        oracle.deleteResponse(id);
        // Do something with the price data
    }

    function handleFailure(uint256 id) public {
        assert(msg.sender == address(oracle));
        bytes32 error = oracle.getResponseError(id);
        oracle.deleteResponse(id);
        emit LogError(error);
    }

}
----
====

The data request is initiated using the +initRequest+ function, which allows the query type (in this example, a request for an intraday price) to be specified, in addition to two callback functions.
This returns a +uint256+ identifier that can then be used to provide additional arguments. The +addArgumentToRequestString+ function is used to specify the Reuters Instrument Code (RIC), here for IBM stock, and pass:[<span class="keep-together"><code>addArgumentToRequestUint</code></span>] allows the timestamp to be specified. Now, passing in an alias for +block.timestamp+ will retrieve the current price for IBM. The request is then executed by the +executeRequest+ function. Once the request has been processed, the oracle contract will call the +onSuccess+ callback function with the query identifier, allowing the resulting data to be retrieved; in the event of retrieval failure, the pass:[<span class="keep-together"><code>onFailure</code></span>] callback will return an error code instead. The available fields that can be retrieved on success include +open+, +high+, +low+, +close+ (OHLC), and +bid+/+ask+ prices.(((range="endofrange", startref="ix_11oracles-asciidoc5")))(((range="endofrange", startref="ix_11oracles-asciidoc4")))(((range="endofrange", startref="ix_11oracles-asciidoc3")))


=== Conclusions

As you can see, oracles provide a crucial service to smart contracts: they bring external facts to contract execution. With that, of course, oracles also introduce a significant risk&#x2014;if they are trusted sources and can be compromised, they can result in compromised execution of the smart contracts they feed.

Generally, when considering the use of an oracle be very careful about the _trust model_. If you assume the oracle can be trusted, you may be undermining the security of your smart contract by exposing it to potentially false inputs. That said, oracles can be very useful if the security assumptions are carefully considered.

Decentralized oracles can resolve some of these concerns and offer Ethereum smart contracts trustless external data. Choose carefully and you can start exploring the bridge between Ethereum and the "real world" that oracles offer.(((range="endofrange", startref="ix_11oracles-asciidoc0")))
